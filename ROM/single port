module rom_single_port #(
    parameter ADDR_WIDTH = 4,       // Address width (e.g., 4 bits = 16 locations)
    parameter DATA_WIDTH = 8        // Data width (e.g., 8 bits per location)
)(
    input clk,                      // Clock input
    input [ADDR_WIDTH-1:0] addr,    // Address input
    output reg [DATA_WIDTH-1:0] data // Data output
);

    // ROM memory array
    reg [DATA_WIDTH-1:0] rom_mem [0:(1<<ADDR_WIDTH)-1];

    // Initialize ROM contents
    initial begin
        rom_mem[0]  = 8'hA1;
        rom_mem[1]  = 8'hB2;
        rom_mem[2]  = 8'hC3;
        rom_mem[3]  = 8'hD4;
        rom_mem[4]  = 8'hE5;
        rom_mem[5]  = 8'hF6;
        rom_mem[6]  = 8'h07;
        rom_mem[7]  = 8'h18;
        rom_mem[8]  = 8'h29;
        rom_mem[9]  = 8'h3A;
        rom_mem[10] = 8'h4B;
        rom_mem[11] = 8'h5C;
        rom_mem[12] = 8'h6D;
        rom_mem[13] = 8'h7E;
        rom_mem[14] = 8'h8F;
        rom_mem[15] = 8'h90;
    end

    // Synchronous read
    always @(posedge clk) begin
        data <= rom_mem[addr];
    end
endmodule

// testbench

module test_rom_single_port;
    reg clk;
    reg [3:0] addr;
    wire [7:0] data;

    rom_single_port uut (
        .clk(clk),
        .addr(addr),
        .data(data)
    );

    // Clock generation
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end

    // ROM read sequence
    initial begin
        $display("Time Addr | Data");
        $monitor("%4t  %2h   | %2h", $time, addr, data);

        addr = 4'h0; #10;
        addr = 4'h1; #10;
        addr = 4'h2; #10;
        addr = 4'h3; #10;
        addr = 4'h4; #10;
        addr = 4'h5; #10;
        addr = 4'h6; #10;
        addr = 4'h7; #10;
        addr = 4'h8; #10;
        addr = 4'h9; #10;
        addr = 4'hA; #10;
        addr = 4'hB; #10;
        addr = 4'hC; #10;
        addr = 4'hD; #10;
        addr = 4'hE; #10;
        addr = 4'hF; #10;
        $finish;
    end
endmodule
